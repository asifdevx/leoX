"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/reducer/nftSlice.ts":
/*!*********************************!*\
  !*** ./src/reducer/nftSlice.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNFT: function() { return /* binding */ createNFT; },\n/* harmony export */   fetchNFTs: function() { return /* binding */ fetchNFTs; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dotenv */ \"./node_modules/dotenv/lib/main.js\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reduxjs/toolkit */ \"./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _components_ABI_abi_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/ABI/abi.json */ \"./src/components/ABI/abi.json\");\n\n\n\n\n\ndotenv__WEBPACK_IMPORTED_MODULE_0___default().config();\nconst CONTRACT_ADDRESS = \"0x8Ef4476E5Ed07dFC9eCA640106F00841F89F5e97\";\nconst createEthContract = async ()=>{\n    console.log(\"Contract Address:\", CONTRACT_ADDRESS);\n    if (!window.ethereum) {\n        console.error(\"MetaMask not detected.\");\n        return;\n    }\n    const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.BrowserProvider(window.ethereum);\n    const signer = await provider.getSigner();\n    const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(CONTRACT_ADDRESS, _components_ABI_abi_json__WEBPACK_IMPORTED_MODULE_1__, signer);\n    console.log(await (contract === null || contract === void 0 ? void 0 : contract.getListPrice()));\n    console.log(await (contract === null || contract === void 0 ? void 0 : contract.getCurrentToken()));\n    return contract;\n};\nconst createNFT = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)(\"nft/createNFT\", async (param)=>{\n    let { tokenURI, price } = param;\n    const contract = await createEthContract();\n    const listprice = await (contract === null || contract === void 0 ? void 0 : contract.getListPrice());\n    const tx = await (contract === null || contract === void 0 ? void 0 : contract.createToken(tokenURI, ethers__WEBPACK_IMPORTED_MODULE_2__.parseEther(price.toString()), {\n        value: listprice,\n        gasLimit: 3000000\n    }));\n    await tx.wait();\n    console.log(\"List Price:\", ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(listprice));\n    console.log(\"Token URI:\", tokenURI);\n    console.log(\"Price:\", ethers__WEBPACK_IMPORTED_MODULE_2__.parseEther(price.toString()));\n    console.log(\"step 1\");\n    return {\n        success: true\n    };\n});\nconst fetchNFTs = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createAsyncThunk)(\"nft/fetchNFTs\", async ()=>{\n    const contract = await createEthContract();\n    const nftsRaw = await (contract === null || contract === void 0 ? void 0 : contract.getAllNfts());\n    console.log(\"Raw NFTs Data:\", nftsRaw);\n    if (!nftsRaw) return [];\n    const nftsArray = Array.from(nftsRaw);\n    console.log(\"nftsArray Data:\", nftsArray);\n    const tokens = await Promise.all(nftsArray.map(async (nft)=>{\n        const tokenId = nft[0].toString();\n        console.log(\"tokenId\", tokenId);\n        let metadata = {\n            name: \"\",\n            description: \"\",\n            image: \"\"\n        };\n        try {\n            const tokenURI = await (contract === null || contract === void 0 ? void 0 : contract.tokenURI(tokenId));\n            const metaRes = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"https://gateway.pinata.cloud/ipfs/\".concat(tokenURI.replace(\"ipfs://\", \"\")));\n            console.log(\"tokenURI\", tokenURI);\n            console.log(\"metaRes\", metaRes);\n            metadata = metaRes.data;\n        } catch (error) {\n            const tokenURI = await (contract === null || contract === void 0 ? void 0 : contract.tokenURI(tokenId));\n            console.log(\"tokenURI\", tokenURI);\n            console.error(\"Error fetching metadata for token\", tokenId, error);\n        }\n        return {\n            tokenId,\n            name: metadata.name || \"Token #\".concat(tokenId),\n            description: metadata.description || \"No description available\",\n            image: metadata.image || \"/placeholder.png\",\n            price: ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(nft[3]),\n            owner: nft[1],\n            seller: nft[2],\n            isSold: nft[4]\n        };\n    }));\n    console.log(\"Formatted NFTs:\", tokens);\n    return tokens;\n});\nconst initialState = {\n    nfts: [],\n    loading: false\n};\nconst nftSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createSlice)({\n    name: \"nft\",\n    initialState,\n    reducers: {},\n    extraReducers (builder) {\n        builder.addCase(createNFT.pending, (state)=>{\n            state.loading = true;\n        }).addCase(createNFT.fulfilled, (state)=>{\n            state.loading = false;\n        }).addCase(fetchNFTs.fulfilled, (state, action)=>{\n            state.nfts = action.payload;\n        });\n    }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (nftSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxPQUFPO1lBQ0xpQztZQUNBRSxNQUFNRCxTQUFTQyxJQUFJLElBQUksVUFBa0IsT0FBUkY7WUFDakNHLGFBQWFGLFNBQVNFLFdBQVcsSUFBSTtZQUNyQ0MsT0FBT0gsU0FBU0csS0FBSyxJQUFJO1lBQ3pCMUIsT0FBT3RCLCtDQUFrQixDQUFDMkMsR0FBRyxDQUFDLEVBQUU7WUFDaENVLE9BQU9WLEdBQUcsQ0FBQyxFQUFFO1lBQ2JXLFFBQVFYLEdBQUcsQ0FBQyxFQUFFO1lBQ2RZLFFBQVFaLEdBQUcsQ0FBQyxFQUFFO1FBQ2hCO0lBQ0Y7SUFHRnBDLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUIrQjtJQUMvQixPQUFPQTtBQUNULEdBQUc7QUFFSCxNQUFNaUIsZUFBeUI7SUFDN0JDLE1BQU0sRUFBRTtJQUNSQyxTQUFTO0FBQ1g7QUFFQSxNQUFNQyxXQUFXMUQsNkRBQVdBLENBQUM7SUFDM0I2QyxNQUFNO0lBQ05VO0lBQ0FJLFVBQVUsQ0FBQztJQUNYQyxlQUFjQyxPQUFPO1FBQ25CQSxRQUNHQyxPQUFPLENBQUMzQyxVQUFVNEMsT0FBTyxFQUFFLENBQUNDO1lBQzNCQSxNQUFNUCxPQUFPLEdBQUc7UUFDbEIsR0FDQ0ssT0FBTyxDQUFDM0MsVUFBVThDLFNBQVMsRUFBRSxDQUFDRDtZQUM3QkEsTUFBTVAsT0FBTyxHQUFHO1FBQ2xCLEdBQ0NLLE9BQU8sQ0FBQzlCLFVBQVVpQyxTQUFTLEVBQUUsQ0FBQ0QsT0FBT0U7WUFDcENGLE1BQU1SLElBQUksR0FBR1UsT0FBT0MsT0FBTztRQUM3QjtJQUNKO0FBQ0Y7QUFFQSwrREFBZVQsU0FBU1UsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9yZWR1Y2VyL25mdFNsaWNlLnRzPzQ0NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IGRvdGVudiBmcm9tIFwiZG90ZW52XCI7XG5pbXBvcnQgKiBhcyBldGhlcnMgZnJvbSBcImV0aGVyc1wiO1xuaW1wb3J0IHsgY3JlYXRlU2xpY2UsIGNyZWF0ZUFzeW5jVGh1bmsgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG5pbXBvcnQgYWJpIGZyb20gXCJAL2NvbXBvbmVudHMvQUJJL2FiaS5qc29uXCI7XG5kb3RlbnYuY29uZmlnKCk7XG5jb25zdCBDT05UUkFDVF9BRERSRVNTID0gXCIweDhFZjQ0NzZFNUVkMDdkRkM5ZUNBNjQwMTA2RjAwODQxRjg5RjVlOTdcIjtcblxuY29uc3QgY3JlYXRlRXRoQ29udHJhY3QgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKFwiQ29udHJhY3QgQWRkcmVzczpcIiwgQ09OVFJBQ1RfQUREUkVTUyk7XG4gIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgY29uc29sZS5lcnJvcihcIk1ldGFNYXNrIG5vdCBkZXRlY3RlZC5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTISwgYWJpLCBzaWduZXIpO1xuICBjb25zb2xlLmxvZyhhd2FpdCBjb250cmFjdD8uZ2V0TGlzdFByaWNlKCkpO1xuICBjb25zb2xlLmxvZyhhd2FpdCBjb250cmFjdD8uZ2V0Q3VycmVudFRva2VuKCkpO1xuXG4gIHJldHVybiBjb250cmFjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVORlQgPSBjcmVhdGVBc3luY1RodW5rKFxuICBcIm5mdC9jcmVhdGVORlRcIixcbiAgYXN5bmMgKHsgdG9rZW5VUkksIHByaWNlIH06IHsgdG9rZW5VUkk6IHN0cmluZzsgcHJpY2U6IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgY29udHJhY3QgPSBhd2FpdCBjcmVhdGVFdGhDb250cmFjdCgpO1xuICAgIGNvbnN0IGxpc3RwcmljZSA9IGF3YWl0IGNvbnRyYWN0Py5nZXRMaXN0UHJpY2UoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0Py5jcmVhdGVUb2tlbihcbiAgICAgIHRva2VuVVJJLFxuICAgICAgZXRoZXJzLnBhcnNlRXRoZXIocHJpY2UudG9TdHJpbmcoKSksXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiBsaXN0cHJpY2UsXG4gICAgICAgIGdhc0xpbWl0OiAzMDAwMDAwLFxuICAgICAgfVxuICAgICk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIGNvbnNvbGUubG9nKFwiTGlzdCBQcmljZTpcIiwgZXRoZXJzLmZvcm1hdEV0aGVyKGxpc3RwcmljZSkpO1xuICAgIGNvbnNvbGUubG9nKFwiVG9rZW4gVVJJOlwiLCB0b2tlblVSSSk7XG4gICAgY29uc29sZS5sb2coXCJQcmljZTpcIiwgZXRoZXJzLnBhcnNlRXRoZXIocHJpY2UudG9TdHJpbmcoKSkpO1xuXG4gICAgY29uc29sZS5sb2coXCJzdGVwIDFcIik7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH1cbik7XG5cbmV4cG9ydCBjb25zdCBmZXRjaE5GVHMgPSBjcmVhdGVBc3luY1RodW5rPE5GVFtdPihcIm5mdC9mZXRjaE5GVHNcIiwgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBjb250cmFjdCA9IGF3YWl0IGNyZWF0ZUV0aENvbnRyYWN0KCk7XG4gIGNvbnN0IG5mdHNSYXcgPSBhd2FpdCBjb250cmFjdD8uZ2V0QWxsTmZ0cygpO1xuICBjb25zb2xlLmxvZyhcIlJhdyBORlRzIERhdGE6XCIsIG5mdHNSYXcpO1xuXG4gIGlmICghbmZ0c1JhdykgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG5mdHNBcnJheSA9IEFycmF5LmZyb20obmZ0c1Jhdyk7XG4gIGNvbnNvbGUubG9nKFwibmZ0c0FycmF5IERhdGE6XCIsIG5mdHNBcnJheSk7XG5cbiAgY29uc3QgdG9rZW5zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbmZ0c0FycmF5Lm1hcChhc3luYyAobmZ0OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuSWQgPSBuZnRbMF0udG9TdHJpbmcoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwidG9rZW5JZFwiLCB0b2tlbklkKTtcblxuICAgICAgbGV0IG1ldGFkYXRhID0geyBuYW1lOiBcIlwiLCBkZXNjcmlwdGlvbjogXCJcIiwgaW1hZ2U6IFwiXCIgfTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW5VUkkgPSBhd2FpdCBjb250cmFjdD8udG9rZW5VUkkodG9rZW5JZCk7XG4gICAgICAgIGNvbnN0IG1ldGFSZXMgPSBhd2FpdCBheGlvcy5nZXQoYGh0dHBzOi8vZ2F0ZXdheS5waW5hdGEuY2xvdWQvaXBmcy8ke3Rva2VuVVJJLnJlcGxhY2UoXCJpcGZzOi8vXCIsIFwiXCIpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhcInRva2VuVVJJXCIsIHRva2VuVVJJKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJtZXRhUmVzXCIsIG1ldGFSZXMpO1xuICAgICAgICBtZXRhZGF0YSA9IG1ldGFSZXMuZGF0YTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVVJJID0gYXdhaXQgY29udHJhY3Q/LnRva2VuVVJJKHRva2VuSWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInRva2VuVVJJXCIsIHRva2VuVVJJKTtcblxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgbWV0YWRhdGEgZm9yIHRva2VuXCIsIHRva2VuSWQsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuSWQsXG4gICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUgfHwgYFRva2VuICMke3Rva2VuSWR9YCxcbiAgICAgICAgZGVzY3JpcHRpb246IG1ldGFkYXRhLmRlc2NyaXB0aW9uIHx8IFwiTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlXCIsXG4gICAgICAgIGltYWdlOiBtZXRhZGF0YS5pbWFnZSB8fCBcIi9wbGFjZWhvbGRlci5wbmdcIixcbiAgICAgICAgcHJpY2U6IGV0aGVycy5mb3JtYXRFdGhlcihuZnRbM10pLFxuICAgICAgICBvd25lcjogbmZ0WzFdLFxuICAgICAgICBzZWxsZXI6IG5mdFsyXSxcbiAgICAgICAgaXNTb2xkOiBuZnRbNF0sXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG5cbiAgY29uc29sZS5sb2coXCJGb3JtYXR0ZWQgTkZUczpcIiwgdG9rZW5zKTtcbiAgcmV0dXJuIHRva2Vucztcbn0pO1xuXG5jb25zdCBpbml0aWFsU3RhdGU6IE5GVFN0YXRlID0ge1xuICBuZnRzOiBbXSxcbiAgbG9hZGluZzogZmFsc2UsXG59O1xuXG5jb25zdCBuZnRTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgbmFtZTogXCJuZnRcIixcbiAgaW5pdGlhbFN0YXRlLFxuICByZWR1Y2Vyczoge30sXG4gIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDYXNlKGNyZWF0ZU5GVC5wZW5kaW5nLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UoY3JlYXRlTkZULmZ1bGZpbGxlZCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShmZXRjaE5GVHMuZnVsZmlsbGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBzdGF0ZS5uZnRzID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICB9KTtcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBuZnRTbGljZS5yZWR1Y2VyO1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiZG90ZW52IiwiZXRoZXJzIiwiY3JlYXRlU2xpY2UiLCJjcmVhdGVBc3luY1RodW5rIiwiYWJpIiwiY29uZmlnIiwiQ09OVFJBQ1RfQUREUkVTUyIsImNyZWF0ZUV0aENvbnRyYWN0IiwiY29uc29sZSIsImxvZyIsIndpbmRvdyIsImV0aGVyZXVtIiwiZXJyb3IiLCJwcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsInNpZ25lciIsImdldFNpZ25lciIsImNvbnRyYWN0IiwiQ29udHJhY3QiLCJnZXRMaXN0UHJpY2UiLCJnZXRDdXJyZW50VG9rZW4iLCJjcmVhdGVORlQiLCJ0b2tlblVSSSIsInByaWNlIiwibGlzdHByaWNlIiwidHgiLCJjcmVhdGVUb2tlbiIsInBhcnNlRXRoZXIiLCJ0b1N0cmluZyIsInZhbHVlIiwiZ2FzTGltaXQiLCJ3YWl0IiwiZm9ybWF0RXRoZXIiLCJzdWNjZXNzIiwiZmV0Y2hORlRzIiwibmZ0c1JhdyIsImdldEFsbE5mdHMiLCJuZnRzQXJyYXkiLCJBcnJheSIsImZyb20iLCJ0b2tlbnMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibmZ0IiwidG9rZW5JZCIsIm1ldGFkYXRhIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiaW1hZ2UiLCJtZXRhUmVzIiwiZ2V0IiwicmVwbGFjZSIsImRhdGEiLCJvd25lciIsInNlbGxlciIsImlzU29sZCIsImluaXRpYWxTdGF0ZSIsIm5mdHMiLCJsb2FkaW5nIiwibmZ0U2xpY2UiLCJyZWR1Y2VycyIsImV4dHJhUmVkdWNlcnMiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInBlbmRpbmciLCJzdGF0ZSIsImZ1bGZpbGxlZCIsImFjdGlvbiIsInBheWxvYWQiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/reducer/nftSlice.ts\n"));

/***/ })

});